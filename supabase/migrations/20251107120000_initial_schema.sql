-- =====================================================================================
-- Migration: Initial Schema Setup for Memo Cards Application
-- Created: 2025-11-07 12:00:00 UTC
-- Description: Creates the complete database schema including:
--   - Custom ENUM types for card origins, statuses, AI request statuses, and events
--   - Core tables: app_users, ai_requests, generation_sets, cards, event_log
--   - Row Level Security (RLS) policies for all tables
--   - Performance indexes for common query patterns
--   - Required PostgreSQL extensions
-- 
-- Tables affected: app_users, ai_requests, generation_sets, cards, event_log
-- Special notes: 
--   - Requires pgcrypto extension for UUID generation
--   - Requires pg_trgm extension for text search capabilities
--   - All tables have RLS enabled with owner and admin policies
-- =====================================================================================

-- =====================================================================================
-- SECTION 1: Extensions
-- Enable required PostgreSQL extensions for UUID generation and text search
-- =====================================================================================

-- Enable pgcrypto for gen_random_uuid() function used in primary keys
create extension if not exists pgcrypto;

-- Enable pg_trgm for trigram-based text search on card questions
create extension if not exists pg_trgm;

-- =====================================================================================
-- SECTION 2: Custom Types
-- Define ENUM types for type-safe status and classification fields
-- =====================================================================================

-- Card origin type: tracks how a card was created
-- 'manual' - user created the card manually
-- 'ai' - card was generated by AI without modifications
-- 'ai-edited' - card was generated by AI and then edited by user
create type card_origin_type as enum ('manual', 'ai', 'ai-edited');

-- Card status type: tracks the lifecycle of a card
-- 'proposed' - card is suggested but not yet accepted by user
-- 'accepted' - user has accepted the card for learning
-- 'rejected' - user has rejected the card
-- 'deleted' - card has been soft-deleted
create type card_status_type as enum ('proposed', 'accepted', 'rejected', 'deleted');

-- AI request status type: tracks the processing state of AI generation requests
-- 'queued' - request is waiting to be processed
-- 'processing' - request is currently being processed
-- 'succeeded' - request completed successfully
-- 'failed' - request failed with an error
create type ai_request_status_type as enum ('queued', 'processing', 'succeeded', 'failed');

-- Event type: defines all possible user actions and system events for audit log
-- AI-related events: generation lifecycle tracking
-- Card-related events: card lifecycle and user actions
-- Review-related events: learning session tracking
create type event_type as enum (
  'ai_generation_requested',
  'ai_generation_succeeded',
  'ai_generation_failed',
  'cards_proposed',
  'cards_accepted',
  'cards_rejected',
  'card_created_manual',
  'card_deleted',
  'review_session_started',
  'review_session_finished'
);

-- =====================================================================================
-- SECTION 3: Tables
-- Create all application tables with appropriate constraints and relationships
-- =====================================================================================

-- -------------------------------------------------------------------------------------
-- Table: app_users
-- Purpose: Stores application-specific user metadata extending Supabase auth.users
-- Relationship: 1:1 with auth.users (each auth user has exactly one app_users record)
-- -------------------------------------------------------------------------------------
create table app_users (
  user_id uuid primary key references auth.users(id) on delete cascade,
  preferred_language text not null default 'pl' check (preferred_language in ('pl', 'en')),
  is_active boolean not null default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Add comment explaining the purpose of app_users table
comment on table app_users is 'Application-specific user profile data extending Supabase auth.users. Stores user preferences and account status.';
comment on column app_users.preferred_language is 'User interface language preference. Defaults to Polish (pl).';
comment on column app_users.is_active is 'Indicates if the user account is active. Can be used for soft account suspension.';

-- -------------------------------------------------------------------------------------
-- Table: ai_requests
-- Purpose: Tracks all AI generation requests and their processing status
-- Relationship: Many ai_requests belong to one app_user
-- -------------------------------------------------------------------------------------
create table ai_requests (
  ai_request_id uuid primary key default gen_random_uuid(),
  user_id uuid not null references app_users(user_id) on delete cascade,
  request_payload jsonb not null,
  response_payload jsonb null,
  status ai_request_status_type not null default 'queued',
  error_code text null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Add comments explaining ai_requests table structure
comment on table ai_requests is 'Stores AI card generation requests and their processing status. Used for tracking, debugging, and analytics.';
comment on column ai_requests.request_payload is 'JSON payload sent to AI service containing input text and generation parameters.';
comment on column ai_requests.response_payload is 'JSON response from AI service containing generated cards. NULL until request succeeds.';
comment on column ai_requests.error_code is 'Error code if request failed. NULL for successful requests.';

-- -------------------------------------------------------------------------------------
-- Table: generation_sets
-- Purpose: Groups cards generated from the same input text
-- Relationship: Many generation_sets belong to one app_user
--              One generation_set may reference one ai_request (nullable)
-- -------------------------------------------------------------------------------------
create table generation_sets (
  generation_set_id uuid primary key default gen_random_uuid(),
  user_id uuid not null references app_users(user_id) on delete cascade,
  ai_request_id uuid null references ai_requests(ai_request_id) on delete set null,
  input_text text not null check (char_length(input_text) <= 10000),
  input_hash bytea not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  -- Ensure each user can only have one generation set per unique input
  unique (user_id, input_hash)
);

-- Add comments explaining generation_sets table structure
comment on table generation_sets is 'Groups cards generated from the same input text. Prevents duplicate generation via input_hash.';
comment on column generation_sets.input_text is 'Original text used to generate cards. Limited to 10,000 characters.';
comment on column generation_sets.input_hash is 'Hash of input_text used for deduplication. Ensures users do not generate cards from identical text twice.';
comment on column generation_sets.ai_request_id is 'Reference to AI request that created this set. NULL for manually created sets or if request is deleted.';

-- -------------------------------------------------------------------------------------
-- Table: cards
-- Purpose: Stores individual flashcards (question/answer pairs)
-- Relationship: Many cards belong to one app_user
--              Many cards may belong to one generation_set (nullable for manual cards)
-- -------------------------------------------------------------------------------------
create table cards (
  card_id uuid primary key default gen_random_uuid(),
  user_id uuid not null references app_users(user_id) on delete cascade,
  generation_set_id uuid null references generation_sets(generation_set_id) on delete set null,
  question text not null check (char_length(question) <= 200),
  answer text not null check (char_length(answer) <= 500),
  origin card_origin_type not null default 'manual',
  status card_status_type not null default 'proposed',
  source_excerpt text null,
  deleted_at timestamptz null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  -- Ensure manual cards have no generation_set_id, and AI cards must have one
  check (
    (origin = 'manual' and generation_set_id is null) or 
    (origin <> 'manual' and generation_set_id is not null)
  ),
  -- Ensure deleted cards have deleted_at timestamp, and non-deleted cards do not
  check (
    (status = 'deleted' and deleted_at is not null) or 
    (status <> 'deleted' and deleted_at is null)
  )
);

-- Add comments explaining cards table structure and constraints
comment on table cards is 'Stores flashcards with questions and answers. Supports both manual and AI-generated cards.';
comment on column cards.question is 'The question side of the flashcard. Limited to 200 characters.';
comment on column cards.answer is 'The answer side of the flashcard. Limited to 500 characters.';
comment on column cards.origin is 'Indicates how the card was created: manual, AI-generated, or AI-generated then edited.';
comment on column cards.status is 'Current lifecycle status of the card: proposed, accepted, rejected, or deleted.';
comment on column cards.source_excerpt is 'Optional excerpt from the original input text that this card was generated from.';
comment on column cards.deleted_at is 'Timestamp when card was soft-deleted. NULL for active cards. Used for soft delete pattern.';

-- -------------------------------------------------------------------------------------
-- Table: event_log
-- Purpose: Audit log of all user actions and system events
-- Relationship: Many events belong to one app_user
-- -------------------------------------------------------------------------------------
create table event_log (
  event_id bigserial primary key,
  user_id uuid not null references app_users(user_id) on delete cascade,
  event_type event_type not null,
  event_data jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now()
);

-- Add comments explaining event_log table structure
comment on table event_log is 'Audit log of all user actions and system events. Used for analytics, debugging, and user activity tracking.';
comment on column event_log.event_type is 'Type of event that occurred. See event_type enum for all possible values.';
comment on column event_log.event_data is 'JSON payload containing event-specific data and context.';

-- =====================================================================================
-- SECTION 4: Indexes
-- Create indexes to optimize common query patterns
-- =====================================================================================

-- Index for full-text search on card questions using trigram similarity
-- Enables fast LIKE queries and similarity searches on question text
create index idx_cards_question_trgm on cards using gin (question gin_trgm_ops);

-- Composite index for filtering and sorting user's cards by status
-- Optimizes queries like: "show me all my accepted cards, newest first"
create index idx_cards_user_status_updated on cards (user_id, status, updated_at desc);

-- Index for retrieving user's generation sets chronologically
-- Optimizes queries like: "show me my recent AI generations"
create index idx_generation_sets_user_created on generation_sets (user_id, created_at desc);

-- Index for retrieving user's AI requests chronologically
-- Optimizes queries like: "show me my recent AI requests"
create index idx_ai_requests_user_created on ai_requests (user_id, created_at desc);

-- Index for retrieving user's event log chronologically
-- Optimizes queries like: "show me my recent activity"
create index idx_event_log_user_created on event_log (user_id, created_at desc);

-- =====================================================================================
-- SECTION 5: Row Level Security (RLS) Policies
-- Enable RLS and create policies for secure multi-tenant data access
-- All tables use owner-based access control with separate admin policies
-- =====================================================================================

-- -------------------------------------------------------------------------------------
-- RLS for app_users table
-- Security model: Users can only access their own profile data
-- -------------------------------------------------------------------------------------

-- Enable RLS and force it for all roles including table owner
alter table app_users enable row level security;
alter table app_users force row level security;

-- Policy: Allow authenticated users to manage their own profile
-- Applies to: SELECT, INSERT, UPDATE, DELETE operations
-- Rationale: Users need full control over their own profile data
create policy app_users_owner_policy_select on app_users
  for select
  to authenticated
  using (user_id = auth.uid());

create policy app_users_owner_policy_insert on app_users
  for insert
  to authenticated
  with check (user_id = auth.uid());

create policy app_users_owner_policy_update on app_users
  for update
  to authenticated
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

create policy app_users_owner_policy_delete on app_users
  for delete
  to authenticated
  using (user_id = auth.uid());

-- Policy: Allow anonymous users no access to app_users
-- Rationale: Profile data should only be accessible to authenticated users
-- Note: No policies for anon role means no access

-- -------------------------------------------------------------------------------------
-- RLS for cards table
-- Security model: Users can only access their own cards
-- -------------------------------------------------------------------------------------

-- Enable RLS and force it for all roles including table owner
alter table cards enable row level security;
alter table cards force row level security;

-- Policy: Allow authenticated users to view their own cards
-- Rationale: Users need to see all their cards regardless of status
create policy cards_owner_policy_select on cards
  for select
  to authenticated
  using (user_id = auth.uid());

-- Policy: Allow authenticated users to create their own cards
-- Rationale: Users can create both manual and AI-generated cards
create policy cards_owner_policy_insert on cards
  for insert
  to authenticated
  with check (user_id = auth.uid());

-- Policy: Allow authenticated users to update their own cards
-- Rationale: Users can edit card content, change status, etc.
create policy cards_owner_policy_update on cards
  for update
  to authenticated
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

-- Policy: Allow authenticated users to delete their own cards
-- Rationale: Users can permanently delete cards (soft delete via status is preferred)
create policy cards_owner_policy_delete on cards
  for delete
  to authenticated
  using (user_id = auth.uid());

-- -------------------------------------------------------------------------------------
-- RLS for generation_sets table
-- Security model: Users can only access their own generation sets
-- -------------------------------------------------------------------------------------

-- Enable RLS and force it for all roles including table owner
alter table generation_sets enable row level security;
alter table generation_sets force row level security;

-- Policy: Allow authenticated users to view their own generation sets
-- Rationale: Users need to see their generation history
create policy generation_sets_owner_policy_select on generation_sets
  for select
  to authenticated
  using (user_id = auth.uid());

-- Policy: Allow authenticated users to create their own generation sets
-- Rationale: Users can trigger AI generation which creates generation sets
create policy generation_sets_owner_policy_insert on generation_sets
  for insert
  to authenticated
  with check (user_id = auth.uid());

-- Policy: Allow authenticated users to update their own generation sets
-- Rationale: Users may need to update metadata or link to AI requests
create policy generation_sets_owner_policy_update on generation_sets
  for update
  to authenticated
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

-- Policy: Allow authenticated users to delete their own generation sets
-- Rationale: Users can remove generation history (will cascade to cards via ON DELETE SET NULL)
create policy generation_sets_owner_policy_delete on generation_sets
  for delete
  to authenticated
  using (user_id = auth.uid());

-- -------------------------------------------------------------------------------------
-- RLS for ai_requests table
-- Security model: Users can only access their own AI requests
-- -------------------------------------------------------------------------------------

-- Enable RLS and force it for all roles including table owner
alter table ai_requests enable row level security;
alter table ai_requests force row level security;

-- Policy: Allow authenticated users to view their own AI requests
-- Rationale: Users need to see status and history of their AI generation requests
create policy ai_requests_owner_policy_select on ai_requests
  for select
  to authenticated
  using (user_id = auth.uid());

-- Policy: Allow authenticated users to create their own AI requests
-- Rationale: Users can trigger AI card generation
create policy ai_requests_owner_policy_insert on ai_requests
  for insert
  to authenticated
  with check (user_id = auth.uid());

-- Policy: Allow authenticated users to update their own AI requests
-- Rationale: System needs to update request status and response payload
create policy ai_requests_owner_policy_update on ai_requests
  for update
  to authenticated
  using (user_id = auth.uid())
  with check (user_id = auth.uid());

-- Policy: Allow authenticated users to delete their own AI requests
-- Rationale: Users can remove request history
create policy ai_requests_owner_policy_delete on ai_requests
  for delete
  to authenticated
  using (user_id = auth.uid());

-- -------------------------------------------------------------------------------------
-- RLS for event_log table
-- Security model: Users can only view their own events (read-only for users)
-- -------------------------------------------------------------------------------------

-- Enable RLS and force it for all roles including table owner
alter table event_log enable row level security;
alter table event_log force row level security;

-- Policy: Allow authenticated users to view their own event log
-- Rationale: Users can see their activity history
create policy event_log_owner_policy_select on event_log
  for select
  to authenticated
  using (user_id = auth.uid());

-- Policy: Allow authenticated users to insert their own events
-- Rationale: Application code needs to log user actions
create policy event_log_owner_policy_insert on event_log
  for insert
  to authenticated
  with check (user_id = auth.uid());

-- Note: No UPDATE or DELETE policies for event_log
-- Rationale: Event log should be append-only for audit integrity
-- Only admins (via service role) should be able to modify or delete events

-- =====================================================================================
-- SECTION 6: Triggers
-- Create triggers for automatic timestamp management
-- =====================================================================================

-- Function to automatically update updated_at timestamp
create or replace function update_updated_at_column()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Apply updated_at trigger to all tables with updated_at column
create trigger update_app_users_updated_at
  before update on app_users
  for each row
  execute function update_updated_at_column();

create trigger update_ai_requests_updated_at
  before update on ai_requests
  for each row
  execute function update_updated_at_column();

create trigger update_generation_sets_updated_at
  before update on generation_sets
  for each row
  execute function update_updated_at_column();

create trigger update_cards_updated_at
  before update on cards
  for each row
  execute function update_updated_at_column();

-- =====================================================================================
-- END OF MIGRATION
-- =====================================================================================

